# Complete Supabase Setup Guide for MVRK Haus

## üìã Table of Contents
1. [Project Overview](#project-overview)
2. [Environment Setup](#environment-setup)
3. [Database Schema](#database-schema)
4. [Authentication Setup](#authentication-setup)
5. [TypeScript Integration](#typescript-integration)
6. [Next.js Configuration](#nextjs-configuration)
7. [Security & RLS](#security--rls)
8. [Best Practices](#best-practices)
9. [Development Workflow](#development-workflow)
10. [Troubleshooting](#troubleshooting)

## üèóÔ∏è Project Overview

**Organization**: mvrkhaus  
**Project ID**: xuoupvqoiuyqidvcibjz  
**Region**: ap-northeast-2 (Asia Pacific - Seoul)  
**Database Version**: PostgreSQL 17.4.1  
**Project URL**: https://xuoupvqoiuyqidvcibjz.supabase.co  

## üîß Environment Setup

### 1. Environment Variables

Create a `.env.local` file in your project root:

```bash
# Supabase Configuration
NEXT_PUBLIC_SUPABASE_URL=https://xuoupvqoiuyqidvcibjz.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_supabase_anon_key_here

# Node Environment
NODE_ENV=development
```

> ‚ö†Ô∏è **Security Note**: Never commit actual keys to version control. Use `.env.example` for templates.

### 2. Supabase Client Configuration

```typescript
// src/lib/supabase.ts
import { createClient } from '@supabase/supabase-js'
import { Database } from './database.types'

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!

export const supabase = createClient<Database>(supabaseUrl, supabaseKey, {
  auth: {
    autoRefreshToken: true,
    persistSession: true,
    detectSessionInUrl: true
  }
})
```

## üóÑÔ∏è Database Schema

### Core Tables

#### 1. User Profiles (`user_profiles`)
```sql
-- Main user profile table
CREATE TABLE user_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id),
  email TEXT NOT NULL UNIQUE,
  full_name TEXT,
  avatar_url TEXT,
  role user_role DEFAULT 'awaiting_match'::user_role NOT NULL,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  
  -- MVRK-specific fields
  mvrkName TEXT,
  bio TEXT,
  instagramId TEXT,
  slug TEXT,
  roleTagIds INTEGER[],
  
  -- June signup fields
  "june-ot-katalkName" TEXT,
  "june-ot-legalName" TEXT,
  
  -- Survey responses
  "1a" TEXT, "2a" TEXT, "3a" TEXT, "4a" TEXT,
  "1b" TEXT, "2b" TEXT, "3b" TEXT, "4b" TEXT, "5b" TEXT, "6b" TEXT
);
```

#### 2. User Roles Enum
```sql
-- User role hierarchy
CREATE TYPE user_role AS ENUM (
  'awaiting_match',    -- New users waiting for approval
  'no_membership',     -- Denied or inactive users
  'general_member',    -- Basic community access
  'editor',           -- Can edit content
  'admin'             -- Full access
);
```

#### 3. Role Tags (`user_profile_roleTagId_enum`)
```sql
-- Role tags for user categorization
CREATE TABLE user_profile_roleTagId_enum (
  id INTEGER PRIMARY KEY,
  roleTagName TEXT NOT NULL
);
```

#### 4. June OTP System (`june-otp`)
```sql
-- OTP verification for June signup campaign
CREATE TABLE "june-otp" (
  id SERIAL PRIMARY KEY,
  kaTalkName TEXT,
  legalName TEXT,
  passcode TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  is_register BOOLEAN DEFAULT FALSE,
  
  -- Survey responses
  "1a" TEXT, "2a" TEXT, "3a" TEXT, "4a" TEXT,
  "1b" TEXT, "2b" TEXT, "3b" TEXT, "4b" TEXT, "5b" TEXT, "6b" TEXT,
  
  instagramID TEXT,
  
  -- Registration tracking
  registered_user_id UUID REFERENCES auth.users(id),
  registered_email TEXT,
  registered_at TIMESTAMPTZ DEFAULT NOW()
);
```

#### 5. OpenHaus Questions (`openhaus_questions_enum`)
```sql
-- Dynamic question system
CREATE TABLE openhaus_questions_enum (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  question_id TEXT,
  question_name TEXT
);
```

### Database Functions

#### User Role Utilities
```sql
-- Get current user's role
CREATE OR REPLACE FUNCTION get_user_role()
RETURNS user_role AS $$
BEGIN
  RETURN (
    SELECT role FROM user_profiles 
    WHERE id = auth.uid()
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Check if user has minimum role level
CREATE OR REPLACE FUNCTION user_has_role_level(minimum_role user_role)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN (
    SELECT CASE 
      WHEN get_user_role() = 'admin' THEN TRUE
      WHEN get_user_role() = 'editor' AND minimum_role IN ('editor', 'general_member', 'awaiting_match') THEN TRUE
      WHEN get_user_role() = 'general_member' AND minimum_role IN ('general_member', 'awaiting_match') THEN TRUE
      WHEN get_user_role() = 'awaiting_match' AND minimum_role = 'awaiting_match' THEN TRUE
      ELSE FALSE
    END
  );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Generate random slug for users
CREATE OR REPLACE FUNCTION generate_random_slug()
RETURNS TEXT AS $$
BEGIN
  RETURN lower(
    substr(md5(random()::text), 1, 8)
  );
END;
$$ LANGUAGE plpgsql;

-- Debug auth context
CREATE OR REPLACE FUNCTION debug_auth_context()
RETURNS TABLE(
  current_user_id UUID,
  current_user_role TEXT,
  is_authenticated BOOLEAN
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    auth.uid() as current_user_id,
    COALESCE(up.role::TEXT, 'no_profile') as current_user_role,
    (auth.uid() IS NOT NULL) as is_authenticated
  FROM user_profiles up
  WHERE up.id = auth.uid();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

## üîê Authentication Setup

### OAuth Configuration

#### Google OAuth Setup
1. **Google Cloud Console**:
   - Enable Google+ API
   - Create OAuth 2.0 credentials
   - Add authorized origins: `https://your-domain.com`, `http://localhost:3000`
   - Add authorized redirect URIs: `https://xuoupvqoiuyqidvcibjz.supabase.co/auth/v1/callback`

2. **Supabase Dashboard**:
   ```
   Authentication > Settings > Auth Providers > Google
   - Enable Google provider
   - Add Client ID and Client Secret
   ```

### Auth Flow Implementation

```typescript
// Sign in with Google
const signInWithGoogle = async () => {
  const { data, error } = await supabase.auth.signInWithOAuth({
    provider: 'google',
    options: {
      redirectTo: `${window.location.origin}/auth/callback`
    }
  })
}

// Handle auth callback
// pages/auth/callback/route.ts
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs'
import { NextRequest, NextResponse } from 'next/server'

export async function GET(request: NextRequest) {
  const requestUrl = new URL(request.url)
  const code = requestUrl.searchParams.get('code')

  if (code) {
    const supabase = createRouteHandlerClient({ cookies })
    await supabase.auth.exchangeCodeForSession(code)
  }

  return NextResponse.redirect(requestUrl.origin)
}
```

### Profile Creation Trigger

```sql
-- Automatically create profile when user signs up
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
  INSERT INTO public.user_profiles (id, email, full_name, avatar_url)
  VALUES (
    NEW.id,
    NEW.email,
    NEW.raw_user_meta_data->>'full_name',
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Trigger the function every time a user is created
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
```

## üìù TypeScript Integration

### Generated Types

Save the following as `src/lib/database.types.ts`:

```typescript
export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      "june-otp": {
        Row: {
          "1a": string | null
          "1b": string | null
          "2a": string | null
          "2b": string | null
          "3a": string | null
          "3b": string | null
          "4a": string | null
          "4b": string | null
          "5b": string | null
          "6b": string | null
          created_at: string | null
          id: number
          instagramID: string | null
          is_register: boolean | null
          kaTalkName: string | null
          legalName: string | null
          passcode: string | null
          registered_at: string | null
          registered_email: string | null
          registered_user_id: string | null
          updated_at: string | null
        }
        Insert: {
          // Insert type definitions...
        }
        Update: {
          // Update type definitions...
        }
        Relationships: []
      }
      user_profiles: {
        Row: {
          "1a": string | null
          "1b": string | null
          "2a": string | null
          "2b": string | null
          "3a": string | null
          "3b": string | null
          "4a": string | null
          "4b": string | null
          "5b": string | null
          "6b": string | null
          avatar_url: string | null
          bio: string | null
          created_at: string | null
          email: string
          full_name: string | null
          id: string
          instagramId: string | null
          "june-ot-katalkName": string | null
          "june-ot-legalName": string | null
          mvrkName: string | null
          role: Database["public"]["Enums"]["user_role"]
          roleTagIds: number[] | null
          slug: string | null
          updated_at: string | null
        }
        Insert: {
          // Insert type definitions...
        }
        Update: {
          // Update type definitions...
        }
        Relationships: []
      }
      // ... other tables
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      debug_auth_context: {
        Args: Record<PropertyKey, never>
        Returns: {
          current_user_id: string
          current_user_role: string
          is_authenticated: boolean
        }[]
      }
      generate_random_slug: {
        Args: Record<PropertyKey, never>
        Returns: string
      }
      get_user_role: {
        Args: Record<PropertyKey, never>
        Returns: Database["public"]["Enums"]["user_role"]
      }
      user_has_role_level: {
        Args: { minimum_role: Database["public"]["Enums"]["user_role"] }
        Returns: boolean
      }
    }
    Enums: {
      user_role:
        | "awaiting_match"
        | "no_membership"
        | "general_member"
        | "editor"
        | "admin"
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

// Helper type exports
export type UserProfile = Database['public']['Tables']['user_profiles']['Row']
export type UserRole = Database['public']['Enums']['user_role']
export type RoleTag = Database['public']['Tables']['user_profile_roleTagId_enum']['Row']
export type Question = Database['public']['Tables']['openhaus_questions_enum']['Row']
```

### Type-Safe Queries

```typescript
// Example: Fetch user profile with full type safety
const fetchUserProfile = async (userId: string): Promise<UserProfile | null> => {
  const { data, error } = await supabase
    .from('user_profiles')
    .select('*')
    .eq('id', userId)
    .single()

  if (error) {
    console.error('Error fetching user profile:', error)
    return null
  }

  return data
}

// Example: Update profile with type checking
const updateProfile = async (userId: string, updates: Partial<UserProfile>) => {
  const { data, error } = await supabase
    .from('user_profiles')
    .update(updates)
    .eq('id', userId)
    .select()
    .single()

  return { data, error }
}
```

## ‚öôÔ∏è Next.js Configuration

### Image Configuration
```typescript
// next.config.ts
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
let supabaseHostname = null;

if (supabaseUrl) {
  try {
    supabaseHostname = new URL(supabaseUrl).hostname;
  } catch (error) {
    console.warn('Failed to parse NEXT_PUBLIC_SUPABASE_URL');
  }
}

const nextConfig: NextConfig = {
  images: {
    remotePatterns: [
      {
        protocol: 'https',
        hostname: 'lh3.googleusercontent.com', // Google avatars
      },
      // Add Supabase storage hostname dynamically
      ...(supabaseHostname ? [{
        protocol: 'https' as const,
        hostname: supabaseHostname,
      }] : [])
    ],
  },
  async headers() {
    return [
      {
        source: '/auth/callback',
        headers: [
          {
            key: 'Cache-Control',
            value: 'no-store, no-cache, must-revalidate, proxy-revalidate',
          },
        ],
      },
    ]
  },
};
```

### Middleware Setup
```typescript
// middleware.ts
import { createMiddlewareClient } from '@supabase/auth-helpers-nextjs'
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export async function middleware(req: NextRequest) {
  const res = NextResponse.next()
  const supabase = createMiddlewareClient({ req, res })

  const {
    data: { session },
  } = await supabase.auth.getSession()

  // Protect admin routes
  if (req.nextUrl.pathname.startsWith('/admin')) {
    if (!session) {
      return NextResponse.redirect(new URL('/sign-in', req.url))
    }
    
    // Check user role
    const { data: profile } = await supabase
      .from('user_profiles')
      .select('role')
      .eq('id', session.user.id)
      .single()
    
    if (profile?.role !== 'admin') {
      return NextResponse.redirect(new URL('/', req.url))
    }
  }

  return res
}

export const config = {
  matcher: ['/admin/:path*', '/profile/:path*']
}
```

## üõ°Ô∏è Security & RLS

### Row Level Security Policies

```sql
-- Enable RLS on all tables
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE "june-otp" ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_profile_roleTagId_enum ENABLE ROW LEVEL SECURITY;
ALTER TABLE openhaus_questions_enum ENABLE ROW LEVEL SECURITY;

-- User profiles: Users can read/update their own profile
CREATE POLICY "Users can view own profile" ON user_profiles
  FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON user_profiles
  FOR UPDATE USING (auth.uid() = id);

-- Admins can view all profiles
CREATE POLICY "Admins can view all profiles" ON user_profiles
  FOR SELECT USING (user_has_role_level('admin'));

-- General members can view other general members
CREATE POLICY "Members can view other members" ON user_profiles
  FOR SELECT USING (
    user_has_role_level('general_member') AND 
    role IN ('general_member', 'editor', 'admin')
  );

-- June OTP: Only admins can manage
CREATE POLICY "Only admins can manage june-otp" ON "june-otp"
  FOR ALL USING (user_has_role_level('admin'));

-- Role tags: Readable by authenticated users
CREATE POLICY "Authenticated users can read role tags" ON user_profile_roleTagId_enum
  FOR SELECT TO authenticated USING (true);

-- Questions: Readable by general members and above
CREATE POLICY "Members can read questions" ON openhaus_questions_enum
  FOR SELECT USING (user_has_role_level('general_member'));
```

### Security Best Practices

1. **API Keys**:
   - Use `NEXT_PUBLIC_` prefix only for client-side keys
   - Keep service role keys server-side only
   - Rotate keys regularly

2. **RLS Policies**:
   - Enable RLS on all user data tables
   - Use role-based access patterns
   - Test policies thoroughly

3. **Data Validation**:
   ```typescript
   // Validate user input before database operations
   const validateProfileUpdate = (data: any) => {
     const allowedFields = ['mvrkName', 'bio', 'instagramId', 'roleTagIds']
     return Object.keys(data).every(key => allowedFields.includes(key))
   }
   ```

## üìö Best Practices

### 1. Error Handling
```typescript
const safeDbOperation = async <T>(
  operation: () => Promise<{ data: T | null, error: any }>
): Promise<T | null> => {
  try {
    const { data, error } = await operation()
    
    if (error) {
      console.error('Database operation failed:', error)
      return null
    }
    
    return data
  } catch (error) {
    console.error('Unexpected error:', error)
    return null
  }
}
```

### 2. Loading States
```typescript
const useAsyncData = <T>(fetchFn: () => Promise<T>) => {
  const [data, setData] = useState<T | null>(null)
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)

  useEffect(() => {
    const loadData = async () => {
      try {
        setLoading(true)
        const result = await fetchFn()
        setData(result)
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error')
      } finally {
        setLoading(false)
      }
    }

    loadData()
  }, [])

  return { data, loading, error }
}
```

### 3. Real-time Subscriptions
```typescript
// Listen to profile changes
useEffect(() => {
  const subscription = supabase
    .channel('profile-changes')
    .on(
      'postgres_changes',
      {
        event: 'UPDATE',
        schema: 'public',
        table: 'user_profiles',
        filter: `id=eq.${user?.id}`
      },
      (payload) => {
        setProfile(payload.new as UserProfile)
      }
    )
    .subscribe()

  return () => {
    subscription.unsubscribe()
  }
}, [user?.id])
```

## üîÑ Development Workflow

### Database Migrations
```sql
-- Migration example: Add new field to user_profiles
-- migrations/20240101000000_add_new_field.sql

ALTER TABLE user_profiles 
ADD COLUMN new_field TEXT;

-- Update RLS policy if needed
DROP POLICY IF EXISTS "Users can update own profile" ON user_profiles;
CREATE POLICY "Users can update own profile" ON user_profiles
  FOR UPDATE USING (auth.uid() = id);
```

### Type Generation
```bash
# Generate fresh TypeScript types
npx supabase gen types typescript --project-id xuoupvqoiuyqidvcibjz > src/lib/database.types.ts
```

### Local Development
```bash
# Start local Supabase (optional)
npx supabase start

# Run migrations
npx supabase db push

# Reset database
npx supabase db reset
```

## üîç Troubleshooting

### Common Issues

1. **Session Issues on Page Refresh**:
   ```typescript
   // Add retry logic for session establishment
   const waitForSession = async (maxAttempts = 5) => {
     for (let i = 0; i < maxAttempts; i++) {
       const { data: { session } } = await supabase.auth.getSession()
       if (session) return session
       
       await new Promise(resolve => setTimeout(resolve, 300))
     }
     return null
   }
   ```

2. **RLS Policy Debugging**:
   ```sql
   -- Check current user context
   SELECT debug_auth_context();
   
   -- Test policy directly
   SELECT * FROM user_profiles WHERE id = auth.uid();
   ```

3. **CORS Issues**:
   - Verify domain settings in Supabase dashboard
   - Check authentication settings
   - Ensure proper redirect URLs

### Debug Utilities

```typescript
// Debug auth state
const debugAuth = async () => {
  const { data: { session } } = await supabase.auth.getSession()
  const { data: profile } = await supabase
    .from('user_profiles')
    .select('*')
    .eq('id', session?.user?.id)
    .single()
    
  console.log('Session:', session)
  console.log('Profile:', profile)
  
  // Test database function
  const { data: authContext } = await supabase
    .rpc('debug_auth_context')
    
  console.log('Auth context:', authContext)
}
```

## üìñ Additional Resources

- [Supabase Documentation](https://supabase.com/docs)
- [Next.js Auth Helpers](https://supabase.com/docs/guides/auth/auth-helpers/nextjs)
- [Row Level Security Guide](https://supabase.com/docs/guides/auth/row-level-security)
- [Real-time Subscriptions](https://supabase.com/docs/guides/realtime)

---

*Last updated: 2024-01-20*  
*Project: MVRK Haus (xuoupvqoiuyqidvcibjz)* 